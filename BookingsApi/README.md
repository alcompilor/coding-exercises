## Om DI, DIP och DRY:

- För Dependency Injection så har jag använt .NETs inbyggda container för att centralisera hanteringen av services. Detta kopplar bort starka beroenden mellan klasser och gör dem enklare att isolera/mocka inf;r unittests. `BookingController` beror inte längre på en konkret `BookingService` utan på `IBookingService` interfacet istället (abstraktion). Samma sak gäller för `BookingService` och `IBookingRepository`. Detta följer Dependency Inversion principen enligt SOLID och underlättar ändring och underhåll av konkreta klasser utan att negativt påverka andra konkreta klasser som beror på dem.
<br />
- Gällande DRY principen har jag samlat allt affärslogik på ett ställe. Logiken för att kolla överlappande bokningar finns nu bara i `BookingService`. Controllern är helt fri från den logiken, den anropar bara servicen och fångar eventuella errors med try/catch. Det gör koden renare och mycket enklare att underhålla.
<br />
*OBS! Jag har övervägt att applicera DRY mellan interfaces, men när jag tänkte efter kom jag fram till att det kan bli en dålig designval i längden. Anledningen är att interfaces föredras vara separata för varje service när man använder Dependency Inversion, och att DRY i detta fall kan i framtiden bryta mot Interface Segregation principen i SOLID.*